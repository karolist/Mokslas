<HTML>
<HEAD>
<TITLE>Словарь терминов</TITLE>
</HEAD>
<!--BODY BGCOLOR="#FFFFFF" TEXT="#000000" link="#0000CC" alink="#0000CC" vlink="#0000CC" onBlur="self.close();" onLoad="for_ie();"-->
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" link="#0000CC" alink="#0000CC" vlink="#0000CC" onBlur="self.close();">

&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>


<A NAME="IA"></A>
<b><font color="#0000CC">Справочная информация по процессорам Intel: </font></b><br>
<small>
<LI> Руководства разработчика по архитектуре Intel (Intel Architecture Developer's Manuals).</LI>
<LI> Курс <I>Оптимизация программ для процессора Pentium</I>® (<I>Optimizing Applications for the Pentium Processor</I>)</LI>
<LI> <I>Руководство по оптимизации для архитектуры Intel</I> (<I>Intel Architecture Optimization Manual</I>, код 242816).</LI>
<LI> Web-сайт Intel для разработчиков: <font color="#0000CC">http://developer.intel.com</font></LI>
</small>


<br><br><br><br><br>

<A NAME="411seq"></A>
<b><font color="#0000CC">Последовательность 4-1-1</font></b><br>

Последовательностью 4-1-1 называется группа из трех команд, которые
могут быть декодированы параллельно, причем:
<LI>
Первая команда преобразуется в 1-4 микрооперации.</LI>

<LI>
Вторая и третья команды преобразуются в 1 микрооперацию каждая.</LI>

<br><br><br><br><br>

<A NAME="4ass"></A>
<b><font color="#0000CC">4-ассоциативность</font></b><br>

Ассоциативность кэш-памяти определяет количество вариантов отображения
области основной памяти, располагающейся по данному адресу, в кэш-линию.

<P>В кэш-памяти с 4-ассоциативностью каждый адрес основной памяти может
быть отображен в любую из четырех кэш-линий.

<br>
<br><br><br><br>

<A NAME="adc"></A>
<b><font color="#0000CC">Команда ADC</font></b><br>

Команда <code><font color="#0000CC">ADC</font></code> выполняет целочисленное сложение двух операндов и флага
переноса (<code><font color="#0000CC">CF</font></code>).

<P>Результат выполнения <code><font color="#0000CC">adc op1, op2</font></code>:
<BR>&nbsp;&nbsp;&nbsp; <code><font color="#0000CC">op1=op1+op2+CF</font></code>
<br>
<br><br><br><br>

<A NAME="addrsizeatr"></A>
<b><font color="#0000CC">Атрибут разрядности адреса</font></b><br>

При выполнении команды процессор обращается к памяти при помощи 16-
или 32-разрядных адресов. Таким образом, каждая команда, обращающаяся к
оперативной памяти, имеет атрибут разрядности адреса, соответствующий 16
или 32 разрядам.

<br>
<br><br><br><br>

<A NAME="addrsizeov"></A>
<b><font color="#0000CC">Префикс несоответствия разрядности адреса (67h)</font></b>
<br>Префикс несоответствия разрядности адреса генерируется, когда разрядность
адреса не соответствует текущему операционному режиму.
В приведенном ниже примере, текущий операционый режим - 16-разрядный,
однако указан 32-разрядный адрес (<code><font color="#0000CC">EBX</font></code>). В результате будет сгенерирован
префикс несоответствия разрядности операнда.
<BR>&nbsp;&nbsp; <code><font color="#0000CC">mov cx, word ptr [ebx]</font></code>

<br>
<br><br><br><br>

<A NAME="and"></A>
<b><font color="#0000CC">Команда AND</font></b><br>

Данная команда вычисляет поразрядное "И" выходного и входного операндов,
и записывает результат на место выходного операнда.

<br>
<br><br><br><br>

<A NAME="backwcondbr"></A>
<b><font color="#0000CC">Условный переход назад</font></b><br>

Условный переход назад есть переход, выполняемый в случае истинности
условия, на метку, располагающуюся выше по тексту. Метка часто соответствует
первой команде цикла.
<BR><B>Пример:</B><code><font color="#0000CC">&nbsp;&nbsp;&nbsp;&nbsp; xor ecx, ecx
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp al, 0
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jnz loop</font></code>

<P>Если значение <code><font color="#0000CC">AL</font></code> отлично от нуля, <code><font color="#0000CC">JNZ</font></code> передает управление на метку <code><font color="#0000CC">loop</font></code>.

<br>
<br><br><br><br>

<A NAME="branch"></A>
<b><font color="#0000CC">Ветвление</font></b><br>

Ветвление есть любая команда, способная прервать последовательное выполнение
команд, например, условные и безусловные переходы, вызовы подпрограмм и
команды возврата, а также прерывания.
<br>
<br><br><br><br>

<A NAME="branchmispred"></A>
<b><font color="#0000CC">Ошибочное предсказание ветвления</font></b><br>

В случае ошибочного предсказания ветвления процессор отбрасывает команды,
выбранные с неверной ветви, и выбирает команды с верной ветви. Выборка
и подготовка к выполнению новых команд занимает много тактов.

<br>
<br><br><br><br>

<A NAME="branchpred"></A>
<b><font color="#0000CC">Предсказание ветвления</font></b><br>

Механизмы статического и динамического предсказания ветвления прогнозируют,
какая последовательность команд скорее всего будет выполнена после ветвления.
Верное предсказание ветвления позволяет поддерживать буферы предварительной
выборки и конвейер выполнения в максимально заполненном и занятом состоянии.

<br>
<br><br><br><br>

<A NAME="BTB"></A>
<b><font color="#0000CC">Буфер адресов ветвления</font></b><br>

Процессоры Pentium ® II и Pentium Pro хранят информацию о не более чем
четырех ранее принятых ветвлениях в кэш-памяти с 512 входами, называемой
буфером адресов ветвления. Они используют информацию из этого буфера для
предсказания последующих ветвлений.

<br>
<br><br><br><br>

<A NAME="birstwrite"></A>
<b><font color="#0000CC">Режим записи в кэш</font></b><br>

Процессор всегда считывает кэш-линию из области памяти, начинающейся
с адреса, кратного 32 байтам. Кэш-линия может быть заполнена из памяти
путем передачи одного фрагмента за четыре операции пересылки по шине. Частичная
заполненность кэш-линий не поддерживается. Таким образом, кэширование даже
одного двойного слова влечет кэширование целой области.

<br>
<br><br><br><br>

<A NAME="cachehit"></A>
<b><font color="#0000CC">Попадание в кэш</font></b><br>

Попадание в кэш происходит, когда требуемые данные или команды находятся
в кэше. Так достигается экономия времени и ресурсов за счет устранения
необходимости выборки из памяти.

<br>
<br><br><br><br>

<A NAME="cashlines"></A>
<b><font color="#0000CC">Кэш-линии</font></b><br>

Процессор начинает чтение каждой кэш-линии из системной памяти с адреса,
кратного 32 байтам. Частичная заполненность кэш-линий
не поддерживается. Таким образом, кэширование даже одного двойного
слова влечет кэширование целой 32-байтной строки.

<br>
<br><br><br><br>

<A NAME="cachemiss"></A>
<b><font color="#0000CC">Промах в кэш</font></b><br>

Промах в кэш есть запрос к памяти, которая в данный момент не кэширована.
Бывают следующие виды промахов в кэш:
<b><i>первичный промах</i></b>
(возникает при первом обращении к ячейке памяти с данным адресом - ее содержимое еще не кэшировано);
<b><i>конфликт</i></b>
(возникает, когда заполнены все кэш-линии, в которые эта ячейка может быть отображена);
<b><i>промах по емкости</i></b>
(возникает, когда уже заполнена вся кэш-память).

<br>
<br><br><br><br>

<A NAME="CALL"></A>
<b><font color="#0000CC">Команда CALL</font></b><br>

<code><font color="#0000CC">CALL</font></code> передает управление подпрограмме, имя которой указывается в качестве
операнда. Когда выполнение подпрограммы завершается ( в ней выполняется
команда <code><font color="#0000CC">RET</font></code>), выполнение продолжается с команды, следующей за <code><font color="#0000CC">CALL</font></code>.

<br>
<br><br><br><br>

<A NAME="CDQ"></A>
<b><font color="#0000CC">Команда CDQ</font></b><br>

Команда <code><font color="#0000CC">CDQ</font></code> преобразует двойное 32-разрядное (двойное) слово в 64-разрядное.
Она удваивает разрядность операнда, находящегося в регистре <code><font color="#0000CC">EAX</font></code>, с учетом
знака, и сохраняет результат в <code><font color="#0000CC">EDX:EAX</font></code>.

<br>
<br><br><br><br>

<A NAME="choproundmode"></A>
<b><font color="#0000CC">Режим округления с отбрасыванием</font></b><br>

В данном режиме округления числа с плавающей точкой округляются вверх
(отрицательные) или вниз (положительные) до ближайшего целого числа.

<br>
<br><br><br><br>

<A NAME="CMOVcc"></A>
<b><font color="#0000CC">Команда CMOVcc</font></b><br>

Команды условной пересылки выполняют следующие действия:
<BR>&nbsp;&nbsp;&nbsp; <B>1.</B> Проверка значения флагов состояния в регистре
<code><font color="#0000CC">EFLAGS</font></code>.
<BR>&nbsp;&nbsp;&nbsp; <B>2.</B> Перенос содержимого входного операнда
в выходной в случае истинности условия (<code><font color="#0000CC"><i>cc</i></font></code>).

<P>Эти команды могут быть использоваться для пересылки значения из ячейки
памяти или регистра общего назначения в другой регистр. Они не изменяют
флаги состояния.

<br>
<br><br><br><br>

<A NAME="complinstr"></A>
<b><font color="#0000CC">Сложная команда</font></b><br>

Сложной является команда, длина которой превышает семь байтов, или команда,
которая декодируется более чем в четыре микрооперации. Только декодер D0
может декодировать сложные команды. Сложные команды не могут декодироваться
параллельно с другими командами.
<p>Длины следующих команд превышают семь байтов:
<BR><code><font color="#0000CC">&nbsp;movzx ebx, word ptr [ecx] + 077fb7426
<BR>&nbsp;lea ecx, dword ptr [esi*02]&nbsp;+&nbsp;0</font></code>
<BR>Вот еще некоторые сложные команды:
<BR><code><font color="#0000CC">&nbsp;CALL</font></code>, <code><font color="#0000CC">RET</font></code>, <code><font color="#0000CC">CMPXCH</font></code>, <code><font color="#0000CC">LOCK</font></code>, <code><font color="#0000CC">CPUID</font></code>.
<p>Команды, содержащие одновременно непосредственный операнд и смещение,
также длиннее семи байтов. Кроме того, префиксы увеличивают длину команды
и могут вывести ее за семь байтов. За детальной информацией о сложных командах
обратитесь к Руководствам разработчика по архитектуре Intel (Intel Architecture
Developer's Manuals).

<br>
<br><br><br><br>

<A NAME="contrldep"></A>
<b><font color="#0000CC">Зависимость по управлению</font></b><br>

Микрооперации зависимы по управлению, если они не могут выполнятьсяодновременно
из-за того, что одна управляет выполнением другой.
Зависимость по управлению предотвратить труднее, чем зависимость по
данным. Процессоры Pentium II и Pentium Pro используют переименование регистров
для разрешения зависимости по данным.

<br><br><br><br><br><br><br><br><br>


<A NAME="CPUID"></A>
<b><font color="#0000CC">Команда CPUID</font></b><br>

<code><font color="#0000CC">CPUID</font></code> предоставляет информацию о процессоре в регистрах IA <code><font color="#0000CC">EAX</font></code>, <code><font color="#0000CC">EBX</font></code>,
<code><font color="#0000CC">ECX</font></code> и <code><font color="#0000CC">EDX</font></code>. Входной параметр, помещаемый в регистр EAX, определяет вид
выдаваемой информации:
<ul><LI>
Поставщик - фирма Intel (<code><font color="#0000CC">EAX</font></code>=0)</LI>

<LI>
Семейство процессора (<code><font color="#0000CC">EAX</font></code>=1)</LI>

<LI>
Модель процессора (<code><font color="#0000CC">EAX</font></code>=1)</LI>

<LI>
"Степпинг" процессора - номер версии в рамках данной
модели (<code><font color="#0000CC">EAX</font></code>=1)</LI>

<LI>
Информация о возможностях (<code><font color="#0000CC">EAX</font></code>=1)</LI>

<LI>
Информация о кэш (<code><font color="#0000CC">EAX</font></code>=2)</LI>
</ul>
<br>
<br><br><br><br>

<A NAME="dynbrpred"></A>
<b><font color="#0000CC">Динамическое предсказание ветвления</font></b><br>

Каждый раз при выполнении команды ветвления процессор сохраняет ее историю
в буфере адресов ветвления (Branch target buffer, BTB). Когда команда ветвления
выбирается снова, процессор использует информацию из буфера, чтобы предсказать,
будет ли выполнен переход.
<BR>Динамическое предсказание ветвления используется для раннего (на этапе
выборки вместо этапа выполнения) обновления значения счетчика команд (IP).
Таким образом, в конвейер войдет меньше команд с неверной ветви.

<br>
<br><br><br><br>

<A NAME="dynexec"></A>
<b><font color="#0000CC">Динамическое выполнение</font></b><br>

Процессоры с поддержкой динамического выполнения, 
такие как Pentium® II и Pentium Pro, имеют следующие 
функциональные возможности:

<LI>Высокооптимизированное предсказание ветвлений</LI>
<LI>Анализ и разрешение зависимостей по данным и регистрам</LI>
<LI>Упреждающее выполнение команд</LI>
<LI>Внеочередное выполнение команд</LI>

<br>
<br><br><br><br>

<A NAME="EFLAGSReg"></A>
<b><font color="#0000CC">Регистр EFLAGS</font></b><br>

32-разрядный регистр <code><font color="#0000CC">EFLAGS</font></code> содержит шесть флагов состояния: <code><font color="#0000CC">CF</font></code> (бит
0), <code><font color="#0000CC">PF</font></code> (бит 2), <code><font color="#0000CC">AF</font></code> (бит 4), <code><font color="#0000CC">ZF</font></code> (бит 6), <code><font color="#0000CC">SF</font></code> (бит 7) и <code><font color="#0000CC">OF</font></code> (бит 11).

<P>За дополнительной информацией о данном регистре обратитесь к Руководству
разработчика по семейству процессоров Pentium Pro, том 2: справочник программиста
(<i>Pentium Pro Family Developer's Manual, Vol. 2: Programmer's Reference</i>).

<br>
<br><br><br><br>

<A NAME="EMMS"></A>
<b><font color="#0000CC">Команда EMMS</font></b><br>

Команду <code><font color="#0000CC">EMMS</font></code> следует использовать в конце фрагментов кода с MMX-командами,
чтобы обеспечить правильное выполнение команд с плавающей точкой. Команда
<code><font color="#0000CC">EMMS</font></code> устанавливает тег-слово регистров с плавающей точкой в значение 'пусто' (все единицы).

<br>
<br><br><br><br>

<A NAME="end_chop"></A>
<b><font color="#0000CC">end_chop()</font></b><br>

Данная C-функция устанавливает режим округления до ближайшего целого.
<p><code><font color="#0000CC">end_chop() {
<BR>&nbsp;&nbsp;&nbsp;__asm {
<BR>&nbsp;&nbsp;&nbsp;fldcw word ptr status</font></code>

<br>
<br><br><br><br>

<A NAME="f2i"></A>
<b><font color="#0000CC">f2i_CurrentRoundMode()</font></b><br>

Данная C-функция преобразует число с плавающей точкой в целое без изменения
режима округления.

<P><code><font color="#0000CC">int f2i_CurrentRoundMode(double d) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__asm {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fld d
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fistp temp_place
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return temp_place;</font></code>

<br>
<br><br><br><br>

<A NAME="fallthcode"></A>
<b><font color="#0000CC">Последовательное выполнение кода</font></b><br>

Последовательное выполнение кода имеет место, когда условный переход
не выполняется.

<br>
<br><br><br><br>

<A NAME="FCMOVcc"></A>
<b><font color="#0000CC">Команда FCMOVcc</font></b><br>

Команды условной пересылки данных с плавающей точкой выполняют следующие
действия:
<p><B>1. </B>Проверка значения флага состояния в регистре
<code><font color="#0000CC">EFLAGS</font></code>.
<BR><B>2. </B>Пересылка содержимого указанного регистра
с плавающей точкой <code><font color="#0000CC">ST(i)</font></code> на верхушку регистрового стека <code><font color="#0000CC">ST(0)</font></code>, если указанное
условие (<code><font color="#0000CC"><i>cc</i></font></code>) выполнено.

<br>
<br><br><br><br>

<A NAME="FISTP"></A>
<b><font color="#0000CC">Команда FISTP</font></b><br>

Команда <code><font color="#0000CC">FISTP</font></code> выполняет следующие действия:

<P><B>1. </B>Преобразование значения в регистре <code><font color="#0000CC">ST(0)</font></code> в знаковое
целое.
<BR><B>2. </B>Cохранение результата в выходном операнде.
<BR><B>3. </B>Выталкивание из регистрового стека.

<br>
<br><br><br><br>

<A NAME="FLDCW"></A>
<b><font color="#0000CC">Команда FLDCW</font></b><br>

Команда <code><font color="#0000CC">FLCW</font></code> загружает 16-разрядный входной операнд в управляющее слово
устройства для работы с плавающей точкой (floating point unit, FPU). Данная
команда часто используется для переключения режима округления FPU.

<br>
<br><br><br><br>

<A NAME="fpregisters"></A>
<b><font color="#0000CC">Регистры с плавающей точкой</font></b><br>

Существует восемь 80-разрядных регистров данных с плавающей точкой,
обозначаемых <code><font color="#0000CC">ST(0)</font></code>...<code><font color="#0000CC">ST(7)</font></code>. Регистры с плавающей точкой используются также
MMX-командами™.

<br>
<br><br><br><br>

<A NAME="forwcondbranch"></A>
<b><font color="#0000CC">Условный переход вперед</font></b><br>

Условный переход вперед есть переход, выполняемый в случае истинности
<BR>условия, на метку, располагающуюся ниже по тексту. Метка часто соответствует
последней команде цикла.
<p><B>Пример:&nbsp; </B><code><font color="#0000CC">&nbsp;&nbsp;cmp eax, 5
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
je L1
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
L1:</font></code>
<p>Если <code><font color="#0000CC">EAX</font></code> равен <code><font color="#0000CC">5</font></code>, <code><font color="#0000CC">Je</font></code> переходит вперед на <code><font color="#0000CC">L1</font></code>.

<br>
<br><br><br><br>

<A NAME="immedop"></A>
<b><font color="#0000CC">Непосредственный операнд</font></b><br>

Непосредственный операнд есть значение данных, содержещееся прямо в
команде, а не находящееся в памяти по адресу, указанному в команде.

<br>
<br><br><br><br>

<A NAME="IMUL"></A>
<b><font color="#0000CC">Команда IMUL</font></b><br>

Команда <font color="#0000CC">IMUL</font></code> выполняет знаковое умножение.

<br>
<br><br><br><br>

<A NAME="inordfrend"></A>
<b><font color="#0000CC">Внешнее сохранение порядка команд</font></b><br>

На этапах выборки и декодирования в конвейере процессор предсказывает
следующее значение счетчика команд и считывает 32-байтную последовательность
команд архитектуры Intel (IA). Затем он подготавливает команды к выполнению
(декодирует их в микрооперации и переименовывает регистры) без изменения
их порядка в конвейере. Наконец, процессор распределяет микрооперации по
устройствам выполнения и записывает микрооперации в буфер перестановок
в порядке исходной последовательной программы.

<br>
<br><br><br><br>

<A NAME="inordretir"></A>
<b><font color="#0000CC">Завершение команд по порядку:</font></b><br>
<LI>Результаты выполнения команд записываются в регистры архитектуры Intel (IA)</LI>
<LI>Если нужно, результаты записываются в кэш или в память (и становятся доступными для операций чтения).</LI>
<LI>Команда удаляется из буфера перестановок.</LI>
Команды завершаются в порядке исходной последовательной программы; это необходимо для сохранения семантики кода.

<br>
<br><br><br><br>

<A NAME="possfpexept"></A>
<b><font color="#0000CC">Возможные исключения при работе с плавающей точкой</font></b><br>

Неправильная очистка разделяемых регистров с плавающей точкой /регистров
MMX после переключения из режима MMX в режим работы с плавающей точкой
может привести к неточному результату, такому как NaN (не число), или к
исключениям при работе с плавающей точкой, таким как переполнение стека,
способных снизить производительность.

<br>
<br><br><br><br>

<A NAME="instrfetun"></A>
<b><font color="#0000CC">Устройство выборки команд</font></b><br>

Устройство выборки команд (instruction fetch unit, IFU) выбирает одну
32-байтную кэш-линию за такт из кэша команд. Оно помечает начало и конец
каждой команды архитектуры Intel (IA) в кэш-линиях&nbsp; и пересылает16
выровненных байтов в декодер.

<P>IFU также вычисляет значение счетчика команд (IP), основываясь на данных
из буфера адресов ветвления, состоянии исключений/прерываний и сигналах
устройств выполнения об ошибочных предсказаниях ветвления.

<br>
<br><br><br><br>

<A NAME="JCC"></A>
<b><font color="#0000CC">Команда JCC</font></b><br>

Это команда условного перехода. В случае истинности условия (<code><font color="#0000CC"><i>cc</i></font></code>) выполняется
переход на метку, указанную в качестве операнда.

<br>
<br><br><br><br>

<A NAME="JGE"></A>
<b><font color="#0000CC">Команда JGE</font></b><br>

Команда <code><font color="#0000CC">JGE</font></code> проверяет состояние флагов <code><font color="#0000CC">SF</font></code> и <code><font color="#0000CC">OF</font></code>.

<P>Если они равны (<code><font color="#0000CC">SF=OF</font></code>), команда выполняет переход на метку, определяемую
выходным операндом. Если они не равны, переход не осуществляется и выполнение
продолжается со следующей команды.

<br>
<br><br><br><br>

<A NAME="latency"></A>
<b><font color="#0000CC">Латентность</font></b><br>

Латентность есть число тактов, которое процессор тратит на вычисление
результатов команды.

<br>
<br><br><br><br>

<A NAME="LEA"></A>
<b><font color="#0000CC">Команда LEA</font></b><br>

Команда <code><font color="#0000CC">LEA</font></code> вычисляет эффективный адрес и сохраняет его в указанном
регистре.

<br>
<br><br><br><br>

<A NAME="loopblock"></A>
<b><font color="#0000CC">Блочная организация циклов</font></b><br>

Блочная организация цикла есть структурирование кода с тем, чтобы он
выполнял несколько операций над блоками данных большой матрицы (пока данные
находятся в кэше), вместо попыток выполнения каждой операции по отдельности
над всеми элементами, по одному за раз.

<P>Так можно выполнять больше операций над теми же данными,&nbsp; пока
они находятся в кэш-памяти.

<br>
<br><br><br><br>

<A NAME="loopfis"></A>
<b><font color="#0000CC">Расщепление циклов</font></b><br>

Расщепление циклов есть разделение большого блока данных, обрабатываемого
в одном цикле, на несколько кэшируемых блоков, и распределение этих блоков
по нескольким циклам. Так увеличивается вероятность того, что данные из
каждого блока все еще будут находиться в кэше, когда они потребуются.

<P>Метод рекомендуется использовать в случаях, когда один цикл включает
в себя отдельные операции над различными большими элементами данных.

<br>
<br><br><br><br>

<A NAME="loopfus"></A>
<b><font color="#0000CC">Объединение циклов</font></b><br>

Объединение циклов есть выборка операций из одного или более циклов,
обрабатывающих одни и те же данные, в отдельный цикл.

<P>Так можно выполнять больше операций над теми же данными, пока они находятся
в кэш-памяти.

<br>
<br><br><br><br>

<A NAME="loopinterch"></A>
<b><font color="#0000CC">Перестановка в цикле</font></b><br>

Перестановка в цикле есть изменение порядка доступа к данным в цикле,
чтобы он соответствовал порядку, в котором компилятор их хранит. Компиляторы
с языка C хранят данные в матрицах по строкам. Компиляторы с языка Fortran
хранят данные в матрицах по столбцам.

<br>
<br><br><br><br>

<A NAME="lowprec"></A>
<b><font color="#0000CC">Низшая точность</font></b><br>

Поле контроля точности (precision control, PC) слова, управляющего работой
с плавающей точкой, задает точность выполнения операций с плавающей точкой.
Если поле очищено, эти операции выполняются с низшей точностью за то же
число тактов, что и целочисленные.

<P>Использование низшей точности для типов данных, удовлетворяющих потребности
вашего кода, предотвращает задержки при доступе в кэш и в память.

<br>
<br><br><br><br>

<A NAME="LRU"></A>
<b><font color="#0000CC">Порядок замещения кэш-линий</font></b><br>
Если нужная ячейка памяти еще не кэширована (т.е. произошел промах в кэш), 
но уже заполнены все кэш-линии, куда эта ячейка может быть отображена, 
то замещается кэш-линия, не использовавшаяся дольше всех.

<br>
<br><br><br><br>

<A NAME="MALLOC"></A>
<b><font color="#0000CC">MALLOC</font></b><br>

Данная функция языка программирования C выделяет пространство в памяти.
За подробностями обратитесь к документации по языку С.

<br>
<br><br><br><br>

<A NAME="microops"></A>
<b><font color="#0000CC">Микрооперации</font></b><br>

Процессоры Pentium® II и Pentium Pro декодируют каждую команду архитектуры
Intel (IA) в одну или несколько простых команд, называемых микрооперациями.

<br>
<br><br><br><br>

<A NAME="microcode"></A>
<b><font color="#0000CC">Микрокод</font></b><br>

Микрокод есть набор заранее запрограммированных последовательностей
микроопераций.

<P>Сложные команды, преобразуемые в более чем четыре микрооперации, требуют
применения микрокода.

<br>
<br><br><br><br>

<A NAME="mmxregs"></A>
<b><font color="#0000CC">Регистры MMX™</font></b><br>

Типы данных MMX могут храниться в любом из восьми регистров MMX. команды
MMX обращаются к этим регистрам напрямую, используя имена <code><font color="#0000CC">MM0</font></code>...<code><font color="#0000CC">MM7</font></code>.
Регистры MMX используются также для работы с плавающей точкой.

<br>
<br><br><br><br>

<A NAME="mmxtechdocs"></A>
<b><font color="#0000CC">Документация по технологии MMX™:</font></b><br>
<small>
<LI>Курс "Введение в технологию MMX" (<i>Introduction to the MMX Technology</i>)</LI>
<LI>Справочное руководство программиста по технологии MMX
(<i>Intel Architecture MMX Technology Programmer's Reference Manual</i>, код 243007).</LI>
<LI>Руководство разработчика по технологии MMX
(<i>Intel Architecture MMX Technology Developer's Manual</i>, код заказа 243006).</LI>
<LI>Руководство по оптимизации для архитектуры Intel 
(<i>Intel Architecture Optimization Guide</i>, код 243195).</LI>
</small>
<br>
<br><br><br><br>

<A NAME="MOV"></A>
<b><font color="#0000CC">Команда MOV</font></b><br>

Команда <code><font color="#0000CC">MOV</font></code> копирует содержимое входного операнда в выходной операнд.
Оба операнда должны иметь одинаковый размер и один из следующих типов:
<LI>
Регистр общего назначения</LI>

<LI>
Сегментный регистр</LI>

<LI>
Ячейка памяти</LI>

<br>
<br><br><br><br>

<A NAME="MOVSX"></A>
<b><font color="#0000CC">Команда MOVSX</font></b><br>

Команда <code><font color="#0000CC">MOVSX</font></code> копирует содержимое входного операнда (регистр или ячейка
памяти) в выходной операнд (регистр), и расширяет с учетом знака его значение
до 16 или 32 битов.

<br>
<br><br><br><br>

<A NAME="MOVZX"></A>
<b><font color="#0000CC">Команда MOVZX</font></b><br>

Команда <code><font color="#0000CC">MOVZX</font></code> копирует содержимое входного операнда (регистр или ячейка
памяти) в выходной операнд (регистр), и расширяет без учета знака его значение
до 16 или 32 битов.

<br>
<br><br><br><br>

<A NAME="nearoundmod"></A>
<b><font color="#0000CC">Режим округления до ближайшего целого</font></b><br>

В этом режиме округления числа с плавающей точкой округляются вверх
или вниз до ближайшего целого числа.

<br>
<br><br><br><br>

<A NAME="nonpre"></A>
<b><font color="#0000CC">ОС без вытесняющей многозадачности</font></b><br>

Операционная система (ОС) без вытесняющей многозадачности не сохраняет
регистровый контекст перед&nbsp; переключением задач. Win 3.1* и DOS* относятся
к ОС без вытесняющей многозадачности.

<P>Win 95* и&nbsp; Win NT* являются операционными системами с вытесняющей
многозадачностью.

<P>В них не требуется выполнение команды <code><font color="#0000CC">EMMS</font></code> перед каждым
переключением задач.

<P>* Все товарные знаки&nbsp; являются собственностью соответствующих
компаний.

<br>
<br><br><br><br>

<A NAME="oppsizeattr"></A>
<b><font color="#0000CC">Атрибут разрядности операнда</font></b><br>

Команда, работающая со одинарными (16 битов) и двойными (32 бита) словами,
имеет атрибут размера операнда, равный соответственно 16 и 32 битам.

<br>
<br><br><br><br>

<A NAME="opsizeovpr"></A>
<b><font color="#0000CC">Префикс несоответствия разрядности операнда (66h)</font></b><br>

<P>Префикс несоответствия разрядности операнда генерируется, когда размер
операнда (в том числе непосредственного) не соответствует текущему операционному
режиму.

<P>В приведенном примере текущий операционный режим - 32-разрядный, однако
указан 16-разрядный операнд (<code><font color="#0000CC">data1</font></code>). Следовательно, будет сгенерирован
атрибут несоответствия разрядности операнда.
<BR>&nbsp;&nbsp;<code><font color="#0000CC">mov ax, word ptr data1</font></code>

<br>
<br><br><br><br>

<A NAME="OR"></A>
<b><font color="#0000CC">Команда OR</font></b><br>

Данная команда выполняет поразрядную операцию "ИЛИ" над&nbsp; выходным
и входным операндами и записывает результат на место выходного операнда.

<br>
<br><br><br><br>

<A NAME="oooexec"></A>
<b><font color="#0000CC">Внеочередное выполнение</font></b><br>

Каждая микрооперация выполняется сразу же, как только разрешаются все зависимости 
по данным и освобождается необходимое устройство выполнения. Порядок выполнения 
может не совпадать с порядком команд в исходной программе.
Результаты внеочередного выполнения временно сохраняются в буфере перестановок,
ожидая, пока станет возможным завершение по порядку.

<br>
<br><br><br><br>

<A NAME="packeddt"></A>
<b><font color="#0000CC">Упакованные типы данных</font></b><br>

Технология MMX™ использует упакованные типы данных: группы по восемь
байтов, четыре слова, или два двойных слова, упакованных в 64-разрядную
группу, а также определяет тип данных "64-разрядное слово".

<P>При работе с конкретной 64-разрядной группой данных тип данных определяет
команда MMX.

<br>
<br><br><br><br>

<A NAME="partregstall"></A>
<b><font color="#0000CC">Конфликт при использовании 8- или 16-разрядных регистров</font></b><br>

Конфликт при использовании 8- или 16-разрядных регистров&nbsp; возникает
в следующих случаях:
<LI>
"Большой" регистр считывается после записи одного из входящих в его состав
8- или 16-разрядных регистров.</LI>

<LI>
Неиспользованная часть "большого" регистра не очищена&nbsp; перед чтением.</LI>


<P>Чтобы узнать, как предотвращать такие конфликты, обратитесь к уроку
"Конфликт при использовании 8- или 16-разрядных регистров " в разделе "Оптимизация
выполнения".

<br>
<br><br><br><br>

<A NAME="partregs"></A>
<b><font color="#0000CC">8- или 16-разрядные регистры</font></b><br>

Младшие 16 битов 32-разрядных регистров общего назначения могут
напрямую отображаться в 8- или 16-разрядные регистры ранних
поколений процессоров Intel.

<P>К примеру, 32-разрядный регистр <code><font color="#0000CC">EAX</font></code>, показанный на рисунке, содержит 16-разрядный
регистр <code><font color="#0000CC">AX</font></code>, содержащий 8-разрядные регистры <code><font color="#0000CC">AH</font></code> 
(старший байт) и <code><font color="#0000CC">AL</font></code> (младший байт).
<br>
<center><img src="images/partregs.gif" width=248 height=78></center>

<br>
<br><br><br><br>

<A NAME="pproarchdocs"></A>
<b><font color="#0000CC">Документация по архитектуре процессора Pentium® Pro</font></b><br>

Сведения о процессорах Pentium® II и Pentium Pro можно найти в <i>Руководстве разработчика по процессорам семейства Pentium Pro</i> 
(Pentium Pro Family Developer's Manual, Volumes 1-3; код 242690, 242691 и 242692) и на Web-сайтe 
<code><font color="#0000CC">http://developer.intel.com</font></code>

<br>
<br><br><br><br>

<A NAME="prefixes"></A>
<b><font color="#0000CC">Префиксы</font></b><br>

Префиксы - это один или несколько байтов в начале команды, модифицирующие
операцию, задаваемую командой.

<P>При работе с процессорами Pentium® II и Pentium Pro избегайте использования
кода, генерирующего префиксы блокировки, указания сегмента, несоответствия
разрядности адреса, несоответствия разрядности операнда и двухбайтные префиксы
карты кода операции. За детальной информацией о префиксах обратитесь к
Руководствам разработчика по архитектуре Intel (Intel Architecture Developer's
Manuals).

<br>
<br><br><br><br>

<A NAME="prevgenprocs"></A>
<b><font color="#0000CC">Документация по предыдущим поколениям процессоров с архитектурой
Intel</font></b><br>

За информацией о процессорах с архитектурой Intel (IA) и технологии
оптимизации для них обратитесь к следующим Курсам и документации:
<LI>
Руководство разработчика по архитектуре Intel (Intel Architecture Developer's
Manuals).</LI>

<LI>
Курс <i>"Оптимизация приложений для процессора Pentium®"</i> (<i>Optimizing Applications
for the Pentium® Processor</i>)</LI>

<LI>
Руководство по оптимизации для архитектуры Intel (<i>Intel Architecture Optimization
Manual</i>, номер заказа 242816).</LI>


<P>Можно также посетить web-сайт фирмы Intel:
<BR>&nbsp;&nbsp;&nbsp; <code><font color="#0000CC">http://developer.intel.com</font></code>

<br>
<br><br><br><br>

<A NAME="regsrenaming"></A>
<b><font color="#0000CC">Переименование регистров</font></b><br>

Процессоры Pentium® II и Pentium Pro отображают восемь внешних регистров&nbsp;
общего назначения и восемь регистров с плавающей точкой в набор из 40 внутреннихрегистров.Переименование
регистров устраняет ложные зависимости и предоставляет больший набор рабочих
регистров. Аппаратное переименование регистров невидимо для программного
обеспечения.

<br>
<br><br><br><br>

<A NAME="ROB"></A>
<b><font color="#0000CC">Буфер перестановок</font></b><br>

Буфер перестановок (reorder buffer, ROB) содержит внутренние аппаратные
регистры общего назначения. Эти регистры хранят информацию о микрооперациях,
которые распределены по конкретным устройствам выполнения, но находятся
на стадии ожидания выполнения, а также о микрооперациях, уже выполненных,
но пока не готовых к завершению.

<P>Результаты выполнения микроопераций, хранимые в буфере перестановок,
не являются окончательными и могут быть отброшены.

<br>
<br><br><br><br>

<A NAME="RS"></A>
<b><font color="#0000CC">Станция резервирования</font></b><br>

Станция резервирования (reservation station,<B> </B>RS) непрерывно сканирует
буфер перестановок в поисках микроопераций, для которых доступны исходные
операнды. Станция резервирования передает каждую микрооперацию одному из
нескольких устройств выполнения, подключенных к каждому из пяти портов
RS.

<br>
<br><br><br><br>

<A NAME="RET"></A>
<b><font color="#0000CC">Команда RET</font></b><br>

Команда <code><font color="#0000CC">RET</font></code> прерывает выполнение подпрограммы и возвращает управление
команде, непосредственно следующей за команде <code><font color="#0000CC">CALL</font></code>, вызвавшей подпрограмму.

<br>
<br><br><br><br>

<A NAME="retaddress"></A>
<b><font color="#0000CC">Адрес возврата</font></b><br>

Процессоры Pentium® II и Pentium Pro предсказывают, что управление из
вызванной процедуры будет возвращено команде, расположенной непосредственно
вслед за <code><font color="#0000CC">CALL</font></code>.

<br>
<br><br><br><br>

<A NAME="RSB"></A>
<b><font color="#0000CC">Буфер адресов возврата</font></b><br>

Как и внутренний стек процессора, буфер адресов возврата хранит
адреса возврата для вложенных вызовов подпрограмм. Это повышает вероятность
верного предсказания адреса возврата из подпрограммы.

<br>
<br><br><br><br>

<A NAME="rotinstrs"></A>
<b><font color="#0000CC">Команды циклического сдвига</font></b><br>

К командам циклического сдвига относятся:
<BR>&nbsp; <code><font color="#0000CC">RCL</font></code> - Циклический сдвиг влево через флаг переноса
<BR>&nbsp; <code><font color="#0000CC">RCR</font></code> - Циклический сдвиг вправо через флаг переноса
<BR>&nbsp; <code><font color="#0000CC">ROL</font></code> - Циклический сдвиг влево
<BR>&nbsp; <code><font color="#0000CC">ROR</font></code> - Циклический сдвиг вправо

<br>
<br><br><br><br>

<A NAME="SAHF"></A>
<b><font color="#0000CC">Команда SAHF</font></b><br>

Команда <code><font color="#0000CC">SAHF</font></code> заполняет флаги <code><font color="#0000CC">SF</font></code>, <code><font color="#0000CC">ZF</font></code>, <code><font color="#0000CC">AF</font></code>, <code><font color="#0000CC">PF</font></code> и <code><font color="#0000CC">CF</font></code> регистра <code><font color="#0000CC">EFLAGS</font></code> значениями
соответствующих битов регистра <code><font color="#0000CC">AH</font></code>.

<br>
<br><br><br><br>

<A NAME="SAL"></A>
<b><font color="#0000CC">Команда SAL</font></b><br>

Команда <code><font color="#0000CC">SAL</font></code> сдвигает биты первого (выходного) операнда влево на число
битов, указанное во втором операнде (счетчике). Она также очищает освободившиеся
биты и загружает в флаг <code><font color="#0000CC">CF</font></code> значение последнего бита, сдвинутого за пределы
операнда.

<br>
<br><br><br><br>

<A NAME="SAR"></A>
<b><font color="#0000CC">Команда SAR</font></b><br>

Команда <code><font color="#0000CC">SAR</font></code> сдвигает биты своего операнда вправо и помещает младший
бит в флаг <code><font color="#0000CC">CF</font></code>.

<br>
<br><br><br><br>

<A NAME="saturation"></A>
<b><font color="#0000CC">Насыщение</font></b><br>

При вычислениях с насыщением, если значение выходит за границы, допустимые
для используемого типа данных, оно заменяется на значение ближайшей границы
диапазона данных.

<P>Например, знаковое слово может принимать значения от <code><font color="#0000CC">8000h</font></code> (-32,768)
до <code><font color="#0000CC">7FFFh</font></code> (32,767). При попытке присвоить переменной данного типа значение
<code><font color="#0000CC">FFFF63C0h</font></code> (-40,000) в действительности будет присвоено <code><font color="#0000CC">8000h</font></code>. Если же присваивается
значение <code><font color="#0000CC">9C40h</font></code> (40,000), оно будет заменено на <code><font color="#0000CC">7FFFh</font></code>.

<br>
<br><br><br><br>

<A NAME="SBB"></A>
<b><font color="#0000CC">Команда SBB</font></b><br>

Команда <code><font color="#0000CC">SBB</font></code> складывает свой второй операнд с флагом переноса (CF), вычитает
результат из первого операнда и записывает результат в первый операнд.

<P>Таким образом, <code><font color="#0000CC">sbb op1,op2</font></code> дает:
<BR><code><font color="#0000CC">&nbsp;&nbsp;op1=op1-(op2+CF)</font></code>

<br>
<br><br><br><br>

<A NAME="setassociative"></A>
<b><font color="#0000CC">Множественная ассоциативность</font></b><br>

Множественная ассоциативность кэш-памяти определяет число кэш-линий,
в которые может быть отображен данный адрес памяти. Все такие кэш-линии
для данного адреса памяти образуют множество.

<br>
<br><br><br><br>


<A NAME="SETcc"></A>
<b><font color="#0000CC">Команда SETcc</font></b><br>

Команда <code><font color="#0000CC">SET<i>cc</i></font></code> устанавливает 8-разрядный выходной операнд в 1, если условие
(<code><font color="#0000CC"><i>cc</i></font></code>) истинно, и в 0, если условие ложно.

<br>
<br><br><br><br>

<A NAME="SETGE"></A>
<b><font color="#0000CC">Команда SETGE</font></b><br>

Команда <code><font color="#0000CC">SETGE</font></code> устанавливает выходной операнд в 1, если флаги состояния
<code><font color="#0000CC">SF</font></code> и <code><font color="#0000CC">OF</font></code> равны (<code><font color="#0000CC">SF=OF</font></code>). В противном случае она устанавливает выходной операнд
в 0.

<br>
<br><br><br><br>

<A NAME="shiftcommands"></A>
<b><font color="#0000CC">Команды сдвига</font></b><br>

К командам сдвига относятся:
<BR>&nbsp; <code><font color="#0000CC">SAL</font></code> - Арифметический сдвиг влево
<BR>&nbsp; <code><font color="#0000CC">SAR</font></code> - Арифметический сдвиг вправо
<BR>&nbsp; <code><font color="#0000CC">SHL</font></code> - Логический сдвиг влево
<BR>&nbsp; <code><font color="#0000CC">SHR</font></code> - Логический сдвиг вправо

<br>
<br><br><br><br>

<A NAME="SHL"></A>
<b><font color="#0000CC">Команда SHL</font></b><br>

Команда <code><font color="#0000CC">SHL</font></code> сдвигает биты выходного операнда влево. При каждом сдвиге
старший бит выходного операнда переносится в флаг <code><font color="#0000CC">CF</font></code>, а младший бит очищается.

<br>
<br><br><br><br>

<A NAME="SIMD"></A>
<b><font color="#0000CC">Технология SIMD</font></b><br>

Технология SIMD (single instruction, multiple data, т.е. одна команда
- много данных) позволяет одной команде обрабатывать параллельно несколько
элементов данных (восемь байтов, четыре слова или два двойных слова).

<br>
<br><br><br><br>

<A NAME="spaclocal"></A>
<b><font color="#0000CC">Близкое расположение</font></b><br>

Близкое расположение имеет место&nbsp; в случаях, когда программа обращается
к ячейкам памяти, располагающимся близко к тем, к которым она недавно обращалась.

<br>
<br><br><br><br>

<A NAME="speculexec"></A>
<b><font color="#0000CC">Упреждающее выполнение</font></b><br>

Упреждающее выполнение основывается на предсказанном потоке управления
программы. Результаты сохраняются временно в связи с тем, что они могут
быть отброшены (отменены) в результате&nbsp; изменений в потоке управления
программы (при ветвлении). Результаты вычислений становятся постоянными
при завершении.


<br>
<br><br><br><br>

<A NAME="start_chop"></A>
<b><font color="#0000CC">start_chop()</font></b><br>

Данная C-функция устанавливает режим округления с отбрасыванием дробной
части.

<P><code><font color="#0000CC">start_chop() {
<BR>&nbsp;&nbsp;__asm {
<BR>&nbsp;&nbsp;fstcw word ptr status
<BR>&nbsp;&nbsp;mov eax, dword ptr status
<BR>&nbsp;&nbsp;or eax,3072
<BR>&nbsp;&nbsp;mov dword ptr chop_status,eax
<BR>&nbsp;&nbsp;fldcw word ptr chop_status</font></code>

<br>
<br><br><br><br>

<A NAME="staticbrpred"></A>
<b><font color="#0000CC">Статическое предсказание ветвления</font></b><br>

Если в буфере адресов ветвления информация о данном ветвлении отсутствует, 
процессор предсказывает ветвление на этапе декодрования, используя алгоритм 
статического предсказания ветвления. Этот алгоритм предсказывает, что:
<ul>
<LI> Безусловный переход будет выполнен</LI>
<LI> Условный переход назад будет выполнен</LI>
<LI> Условный переход вперед не будет выполнен (предсказывается последовательное выполнение кода).</LI>
</ul>
Статическое предсказание ветвления выполняется в конвейере позже, чем
динамическое (при декодировании, а не при выборке). В результате, если
ветвление предсказано неверно, требуется больше тактов на восстановление.

<br>
<br><br><br><br>

<A NAME="statusflags"></A>
<b><font color="#0000CC">Флаги состояния</font></b><br>

Регистр <code><font color="#0000CC">EFLAGS</font></code> содержит шесть флагов состояния: <code><font color="#0000CC">CF</font></code> (бит 0), <code><font color="#0000CC">PF</font></code> (бит
2), <code><font color="#0000CC">AF</font></code> (бит 4), <code><font color="#0000CC">ZF</font></code> (бит 6), <code><font color="#0000CC">SF</font></code> (бит 7) и <code><font color="#0000CC">OF</font></code> (бит 11).

<P>Обратитесь к Руководству разработчика по процессорам семейства
Pentium Pro, том 2: cправочник программиста (<I>Pentium Pro Family
Developer's Manual, Vol. 2: Programmer's Reference manual</I>) за
дополнительной информацией о данных флагах, командах, их устанавливающих
и их использовании.

<br>
<br><br><br><br>

<A NAME="SUB"></A>
<b><font color="#0000CC">Команда SUB</font></b><br>

Команда <code><font color="#0000CC">SUB</font></code> вычитает второй операнд из первого, присваивает результат
вычитания первому операнду и соответственно изменяет значения флагов.

<br>
<br><br><br><br>

<A NAME="synchexec"></A>
<b><font color="#0000CC">Синхронизация выполнения</font></b><br>

При изменении режима округления параллельная обработка прерывается&nbsp;
на время, необходимое для переключения режима округления.

<P>Процессор завершает выполнение всех команд, уже начавших выполняться,
в прежнем режиме округления. До завершения этого процесса никакие новые
команды не могут выполняться.

<P>После выполнения всех команд, поступивших до изменения режима округления,
режим переключается и начинается выполнение последующих команд.

<br>
<br><br><br><br>

<A NAME="sysflagsregs"></A>
<b><font color="#0000CC">Системные флаги и регистры</font></b><br>

Вы можете использовать системные флаги управления кэш-памятью и регистры
диапазонов&nbsp; памяти (memory-type range registers, MTRR) для установки
режимов доступа к диапазонам физических адресов системной памяти.

<P>Это позволяет применять наилучший режим записи для различных типов памяти,
включая ОЗУ, ПЗУ, буфер кадра и отображенные в память устройства ввода-вывода.

<P>За дополнительной информацией о том, как управлять системными флагами
и регистрами, обратитесь к Руководству разработчика по Процессорам
семейства Pentium Pro, том 3: руководство разработчика операционных
систем (<i>Pentium Pro Family Developer's Manual, Vol. 3: Operating
System Writer's Guide</i>).

<br>
<br><br><br><br>

<A NAME="templocality"></A>
<b><font color="#0000CC">Локальность во времени</font></b><br>

Локальность во времени имеет место в случаях, когда программа обращается
к одной и той же ячейке памяти несколько раз в течение краткого промежутка
времени.

<br>
<br><br><br><br>

<A NAME="UCwritepol"></A>
<b><font color="#0000CC">Режим записи без кэширования (uncacheable write policy)</font></b><br>

При записи в память в этом режиме данные не кэшируются. Вместо этого
они записываются непосредственно в системную память, по одному элементу
данных за раз, в порядке исходной последовательной программы.

<P>Данный режим подходит для отображенных в память устройств ввода-вывода

<br>
<br><br><br><br>

<A NAME="uncondbranch"></A>
<b><font color="#0000CC">Безусловный переход</font></b><br>

Безусловный переход передает управление в определенное место потока
команд (точку назначения). Точка назначения может располагаться как в том
же сегменте кода (ближний переход), так и в другом (дальний переход).


<br>
<br><br><br><br>

<A NAME="WBwritepol"></A>
<b><font color="#0000CC">Режим обратной записи (write back write policy)</font></b><br>

При работе с памятью в этом режиме запросы на чтение и запись в системную
память работают с кэш-памятью. Данные попадают в системную память, только
когда необходимо замещение кэш-линии. Данный режим&nbsp; записи уменьшает&nbsp;
поток информации по системной шине, устраняя ненужные обращения к памяти
на запись. Буфер записи не используется.

<br>
<br><br><br><br>

<A NAME="writebuf"></A>
<b><font color="#0000CC">Буфер записи</font></b><br>

Буфер записи временно хранит результаты записи в один и тот же 32-байтный
выровненный фрагмент памяти. Процессор записывает в память содержимое буфера
записи в следующих случаях:
<p><LI>
Выполняется запись в другой 32-байтный выровненный&nbsp; фрагмент&nbsp;
памяти режиме записи с буферизацией.</LI>

<LI>
Выполняется запись в область памяти в режиме&nbsp; записи без кэширования.</LI>

<LI>
Возникла проблема сериализации.</LI>


<P>Если все 32 байта буфера записи были изменены, процессор записывает
его содержимое в память за одну операцию. Если некоторые байты не изменялись,
процессор производит запись посредством от одной до четырех операций.

<br>
<br><br><br><br>

<A NAME="writecombwrpol"></A>
<b><font color="#0000CC">Режим записи с буферизацией (write combining write policy)</font></b><br>

При работе с памятью в этом режиме, при записи данные не попадают в
кэш, а накапливаются в 32-байтном буфере записи. Данные попадают в память
только при сбрасывании буфера записи. При правильной работе в данном режиме
можено уменьшить число обменов с памятью.

<P>Режим записи с буферизацией особенно полезен при значительном превышении
числа операций чтения из памяти над числом операций записи (например, в
буфере кадра).

<br>
<br><br><br><br>

<A NAME="Wrprotwritepol"></A>
<b><font color="#0000CC">Режим защищенной записи (write protected write policy)</font></b><br>

При работе с памятью в этом режиме операции записи работают с системной
памятью и распространяются по системной шине. Операция записи в память
в данном режиме помечает соответствующие кэш-линии всех процессоров как
непригодные.


<br>
<br><br><br><br>

<A NAME="WTwritepol"></A>
<b><font color="#0000CC">Режим сквозной записи (write through write policy)</font></b><br>

При работе с памятью в данном режиме операции записи работают с кэш-памятью
(кроме случаев, когда кэш-линия помечена как непригодная) и с системной
памятью.

<P>Данный режим поддерживает согласованность процессорных кэшей и системной
памяти.

<br>
<br><br><br><br>

<A NAME="XOR"></A>
<b><font color="#0000CC">Команда XOR</font></b><br>

Команда <code><font color="#0000CC">XOR</font></code> вычисляет поразрядное исключающее "ИЛИ" двух операндов.
Каждый бит результата равен 1, если соответствующие биты операндов различны,
и 0, если они равны. Результат помещается на место первого операнда. Команда
модифицирует флаги условий.

<p>Команда <code><font color="#0000CC">xor reg1, reg1</font></code> может использоваться для обнуления регистра,
так как она устанавливает все биты <code><font color="#0000CC">REG1</font></code> в 0.

<br>
<br><br><br><br>

<A NAME="statvars"></A>
<b><font color="#0000CC">Статические переменные</font></b><br>

Память под статические переменные чаще всего отводится компилятором.
Распределение памяти под статические переменные остается неизменным при
выполнении всех блоков и секций кода программы.


<br>
<br><br><br><br>

<A NAME="dynvars"></A>
<b><font color="#0000CC">Динамические переменные</font></b><br>

Память под динамические переменные отводится в сегменте кода.
Распределение может меняться при необходимости для других сегментов кода
в процессе прогона программы.

<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>
<p>&nbsp;<br>

</BODY>
</HTML>

