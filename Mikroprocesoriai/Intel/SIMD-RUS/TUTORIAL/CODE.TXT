Для возврата к учебному курсу закройте  это окно.
Этот файл содержит все фрагменты кода, используемые в данном уроке. 


ПРОВЕРКА ПРОЦЕССОРНОЙ ПОДДЕРЖКИ 

Следующий код служит для проверки поддержки новых SIMD-команд
со стороны процессора:

boolean Streaming_SIMD_Extensions = TRUE

try {
	IssueStreamingSIMDExtensionsload();
}
except (UNWIND) {
	Streaming_SIMD_Extensions = FALSE
}


ПРОВЕРКА ПОДДЕРЖКИ НЕМАСКИРОВАННЫХ ИСКЛЮЧЕНИЙ СО СТОРОНЫ ОС

Следующий код служит для проверки поддержки немаскированных 
исключений со стороны операционной системы:

boolean unmasked_work = TRUE

try {
	IssueUnMask();
}
except (UNWIND) {
	unmasked_work =FALSE
}


ПЕРЕГРУППИРОВКА ДАННЫХ ДЛЯ ТЕХНОЛОГИИ SIMD 

Следующий фрагмент кода производит перегруппировку x,y,z и w-компонент
и занесение их в четыре XMM-регистра:

;ebx = указатель на адрес памяти, по которому содержатся компоненты
вершин v0, v1, v2, v3
	movlps xmm0, [ebx]      ;загрузить x,y для v0 в низ  xmm0
	movhps xmm0, [ebx+32]   ;загрузить x,y для v1 в верх xmm0
	movlps xmm2, [ebx+64]   ;загрузить x,y для v2 в низ  xmm2
	movhps xmm2, [ebx+96]   ;загрузить x,y для v3 в верх xmm2

	movaps xmm1, xmm0       ;копировать xmm0 в xmm1	
	shufps xmm0, xmm2, 88h  ;выделить x-компоненты
	shufps xmm1, xmm2, DDh  ;выделить y-компоненты 

	movlps xmm2, [ebx+8]    ;загрузить z,w для v0 в низ  xmm2
	movhps xmm2, [ebx+40]   ;загрузить z,w для v1 в верх xmm2
	movlps xmm4, [ebx+72]   ;загрузить z,w для v2 в низ  xmm4
	movhps xmm4, [ebx+104]  ;загрузить z,w для v3 в верх xmm4

	movaps xmm3, xmm2       ;копировать xmm2 в xmm3	
	shufps xmm2, xmm4, 88h  ;выделить z-компоненты
	shufps xmm3, xmm4, DDh  ;выделить w-компоненты
	
; end



УCЛОВНАЯ ВЫБОРКА 

Этот код иллюстрирует типичную задачу наложения изображений.

Определим следующие константы:
;mm0 содержит все единицы
;mm1 содержит изображение героя
;mm7 содержит фон изображения (синий)

; Первые 8 пикселов строки 
	pcmeqb    mm7, mm1    ;создать маску героя 
	pxor      mm7, mm0    ;инвертировать маску  
	maskmovq  mm1, mm7    ;записать в память согласно байтовой маске 
; end



CКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ ВЕКТОРОВ

Следующий код служит для вычисления скалярного произведения двух 
4-компонентных векторов:  

movaps  xmm0, [Vector1]     ;Загрузить первый вектор: a3,a2,a1,a0
mulps   xmm0, [Vector2]     ;умножить покомпонентно на второй
                            ;f3=a3*b3,f2=a2*b2,f1=a1*b1,f0=a0*b0     
movaps  xmm1, xmm0;         ;Копировать результаты
shufps  xmm1, xmm1, 4Eh;    ;Переставить: f1,f0,f3,f2
addps   xmm0, xmm1;         ;Сложить: f3+f1,f2+f0,f1+f3,f0+f2 
movaps  xmm1, xmm0;         ;Копировать результаты
shufps  xmm1, xmm1, 11h;    ;Переставить: f0+f2,f1+f3,f0+f2,f1+f3 
addps   xmm0, xmm1;         ;Сложить: f0+f1+f2+f3,f0+f1+f2+f3, 
                                      f0+f1+f2+f3,f0+f1+f2+f3
; Результат во всех элементах xmm0
; end

УМНОЖЕНИЕ МАТРИЦЫ НА ВЕКТОР

Следующий код служит для умножения матрицы 4х4 на каждый из четырех 
заданных векторов (вершин объекта).

;ecx = 	Служит счетчиком цикла (по 4 вершины за цикл)
;esi = 	Указывает на начальный адрес матрицы
;list =	Указывает на начальный адрес данных в структуре SOA 
;X, Y, Z и W являются смещениями соответствующих массивов в структуре. 

movaps xmm0, [list+X+ecx] ;загрузить x-компоненты		
movaps xmm2, [list+Y+ecx] ;загрузить y-компоненты
movaps xmm3, [list+Z+ecx] ;загрузить z-компоненты
movaps xmm1, [esi+m00]    ;m00	m00	m00	m00 
movaps xmm4, [esi+m01]    ;m01	m01	m01	m01
mulps  xmm1, xmm0         ;x*m00 x*m00 x*m00 x*m00
mulps  xmm4, xmm2         ;y*m01 y*m01 y*m01 y*m01	
addps  xmm4, xmm1         ;сложить полученные результаты
movaps xmm1, [esi+m02]    ;m02  m02   m02   m02
mulps  xmm1, xmm3         ;z*m02 z*m02 z*m02 z*m02
addps  xmm4, xmm1         ;сложить полученные результаты
addps  xmm4, [esi+m03]    ;добавить последний элемент строки матрицы
                          ;конец умножения строки
;повторить для всех строк матрицы.
; end


ПРИБЛИЖЕННЫЕ ВЫЧИСЛЕНИЯ И ДЕЛЕНИЕ 

Предлагаемые фрагменты кода решают задачу нахождения обратного значения 
для числа с плавающей запятой тремя разными способами. 
Приближенное нахождение по справочной таблице самое быстрое, 
но не дает высокой точности. 
Алгоритм Ньютона-Рафсона позволяет повысить точность. 
Деление дает наивысшую точность, но выполняется медленно.

Определим следующие константы:
;INIT9 = [9,9,9,9]
;One =	1

;Приближенное определение 1/9 с помощью команды rcpps 
	movaps xmm0, [INIT9]
	rcpps  xmm1,xmm0      ; xmm1 = 9; xmm1 = ~1/9

;Уточнение результата по методу Ньютона-Рафсона
	mulps xmm0,xmm1   ;xmm0 = 9 * ~1/9
	mulps xmm0,xmm1   ;xmm0 = 9 * ~1/9 * ~1/9
	addps xmm1,xmm1   ;xmm1 = 2 * ~1/9
	subps xmm1,xmm0   ;xmm1 = 2 * ~1/9 - 9 * ~1/9 * ~1/9

;Деление командой divps 
	movaps xmm0,[INIT9]
	movaps xmm3,[One]	
	divps  xmm3,xmm0    ;xmm3 = a; xmm0 = 1/9



УСТРАНЕНИЕ ВЕТВЛЕНИЯ

Этот код сравнивает с 1 каждое из четырех чисел ХММ-регистра и выполняет действия, 
зависящие от результата сравнения.
Эквивалентный код на C следующий:
	if(xmm[i]>0) 
 		xmm[i]=xmm[i]+1.
	else
 		xmm[i]=xmm[i]-1.

Определим следующие константы:
;One = 	     [1,1,1,1]
;MinusOne =  [-1,-1,-1,-1]
;Zero =      [0,0,0,0]
;Convert=    [9.58682, -34.5567, -0.555, 0.2345]

	movaps  xmm3,[One]
	movaps  xmm4,[MinusOne]	
	movaps  xmm0,[Convert]
	movaps  xmm1,xmm0
	cmpltps xmm0,[Zero]
	andps   xmm4,xmm0
	andnps	xmm0,xmm3
	addps   xmm1,xmm4
	addps   xmm1,xmm0
; end



ПРОВЕРКА КОЭФФИЦИЕНТОВ ОСЛАБЛЕНИЯ 

Этот код проверяет коэффициенты ослабления и обеспечивает, 
чтобы их значения были не меньше единицы.
Эквивалентный код на C следующий:
	if(Att[i]<1) 
 		xmm[i]=1
	else
 		xmm[i]=Att[i]

Определим следующие константы:
;One = [1,1,1,1]
;Att = [0.2345,0.8652,1.2385,2.9686]

	movaps xmm0, [Att]   ;Загрузить четыре коэффициента в xmm0
	maxps  xmm0, [One]   ;Значения, меньшие 1, сделать равными 1.



ПРЕОБРАЗОВАНИЕ ЧИСЕЛ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ В ЦЕЛЫЕ

Этот код выполняет преобразование четырех SPFP-чисел XMM регистра  в целые числа в 
двух  MMX™ регистрах.

Определим следующие константы:
;Convert = 103.501, 134.324, 71.506, 102.436 

	movaps    xmm0,[Convert]
	cvttps2pi mm0, xmm0			
	shufps    xmm0,xmm0,Eh
	cvttps2pi mm1, xmm0					
; end



АЛЬФА-ПОРОГ

Этот код уменьшает RGB-компоненты до порогового значения alpha, 
cнижая цветовую насыщенность изображения.

Определим следующие константы:
;const_0xff00= 	[ff, 00, ff, 00, ff, 00, ff, 00]

	movq mm3, const_0xff00	;загрузить в mm3 константу (маску)
	movq mm0, [esi]         ;загрузить RGB-данные из [esi] в mm0
	movq mm1, mm0           ;копировать mm0 в mm1
	pshufw mm1, mm1, 5fh    ;переставить alpha в mm1 на место G,R 
	pand mm1, mm3           ;обнулить B-компоненты, оставив alpha
	movq mm2, mm1           ;копировать mm1 в mm2
	psrlq mm2, 8            ;сдвинуть содержимое mm2 на 8 бит вправо
	por mm1, mm2            ;записать alpha-компоненты в mm1
	pminub mm0, mm1         ;взять минимум из RGB и alpha



ЦЕЛОЧИСЛЕННОЕ УМНОЖЕНИЕ БЕЗЗНАКОВЫХ СЛОВ

Этот код повышает точность результатов умножения.

Определим следующие константы:
;BBB = 7160h = 3.543, by 213
;CCC = [FF00,0010,00FF,FFE0]
;BBB1= [7160*2,7160*2,7160*2,7160*2]
;S2US= [8000h,8000h,8000h,8000h]
;MMM = [7160h,7160h,7160h,7160h]

;код с использованием новых SIMD-команд
	movq  mm2, mmword ptr CCC   ;загрузить данные из памяти
	movq  mm3, mmword ptr BBB1  ;загрузить оптимальные множители
	paddw mm2, mmword ptr S2US  ;преобразовать в числа без знака
	pumlhuw mm2, mm3            ;выполнить беззнаковое умножение
	psubw mm2, mmword ptr MMM   ;преобразовать в числа со знаком
	psllw mm2, 2                ;компенсирующий сдвиг



ПРЕДОТВРАЩЕНИЕ ЗАДЕРЖЕК ПУТЕМ УПРЕЖДАЮЩЕГО КЭШИРОВАНИЯ

Этот код уменьшает задержки за счет использования команды prefetch.

loop
    movaps xmm1, [edx + ebx]
    movaps xmm2, [edx + ebx + 16]
    prefetcht1   [edx + ebx + 32]  ;Кэшировать данные заранее
    ;...
    add ebx,32
    cmp ebx, buff_size
jl loop


